package datadog

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
    "github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Span) DecodeMsg(dc *msgp.Reader) (err error) {
    var field []byte
    _ = field
    var zb0001 uint32
    zb0001, err = dc.ReadMapHeader()
    if err != nil {
        err = msgp.WrapError(err)
        return
    }
    for zb0001 > 0 {
        zb0001--
        field, err = dc.ReadMapKeyPtr()
        if err != nil {
            err = msgp.WrapError(err)
            return
        }
        switch msgp.UnsafeString(field) {
        case "name":
            z.Name, err = dc.ReadString()
            if err != nil {
                err = msgp.WrapError(err, "Name")
                return
            }
        case "service":
            z.Service, err = dc.ReadString()
            if err != nil {
                err = msgp.WrapError(err, "Service")
                return
            }
        case "start":
            z.Start, err = dc.ReadInt64()
            if err != nil {
                err = msgp.WrapError(err, "Start")
                return
            }
        case "duration":
            z.Duration, err = dc.ReadInt64()
            if err != nil {
                err = msgp.WrapError(err, "Duration")
                return
            }
        case "meta":
            var zb0002 uint32
            zb0002, err = dc.ReadMapHeader()
            if err != nil {
                err = msgp.WrapError(err, "Meta")
                return
            }
            if z.Meta == nil {
                z.Meta = make(map[string]string, zb0002)
            } else if len(z.Meta) > 0 {
                for key := range z.Meta {
                    delete(z.Meta, key)
                }
            }
            for zb0002 > 0 {
                zb0002--
                var za0001 string
                var za0002 string
                za0001, err = dc.ReadString()
                if err != nil {
                    err = msgp.WrapError(err, "Meta")
                    return
                }
                za0002, err = dc.ReadString()
                if err != nil {
                    err = msgp.WrapError(err, "Meta", za0001)
                    return
                }
                z.Meta[za0001] = za0002
            }
        case "span_id":
            z.SpanID, err = dc.ReadUint64()
            if err != nil {
                err = msgp.WrapError(err, "SpanID")
                return
            }
        case "trace_id":
            z.TraceID, err = dc.ReadUint64()
            if err != nil {
                err = msgp.WrapError(err, "TraceID")
                return
            }
        case "parent_id":
            z.ParentID, err = dc.ReadUint64()
            if err != nil {
                err = msgp.WrapError(err, "ParentID")
                return
            }
        default:
            err = dc.Skip()
            if err != nil {
                err = msgp.WrapError(err)
                return
            }
        }
    }
    return
}

// EncodeMsg implements msgp.Encodable
func (z *Span) EncodeMsg(en *msgp.Writer) (err error) {
    // omitempty: check for empty values
    zb0001Len := uint32(8)
    var zb0001Mask uint8 /* 8 bits */
    if z.Meta == nil {
        zb0001Len--
        zb0001Mask |= 0x10
    }
    // variable map header, size zb0001Len
    err = en.Append(0x80 | uint8(zb0001Len))
    if err != nil {
        return
    }
    if zb0001Len == 0 {
        return
    }
    // write "name"
    err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
    if err != nil {
        return
    }
    err = en.WriteString(z.Name)
    if err != nil {
        err = msgp.WrapError(err, "Name")
        return
    }
    // write "service"
    err = en.Append(0xa7, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65)
    if err != nil {
        return
    }
    err = en.WriteString(z.Service)
    if err != nil {
        err = msgp.WrapError(err, "Service")
        return
    }
    // write "start"
    err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x72, 0x74)
    if err != nil {
        return
    }
    err = en.WriteInt64(z.Start)
    if err != nil {
        err = msgp.WrapError(err, "Start")
        return
    }
    // write "duration"
    err = en.Append(0xa8, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
    if err != nil {
        return
    }
    err = en.WriteInt64(z.Duration)
    if err != nil {
        err = msgp.WrapError(err, "Duration")
        return
    }
    if (zb0001Mask & 0x10) == 0 { // if not empty
        // write "meta"
        err = en.Append(0xa4, 0x6d, 0x65, 0x74, 0x61)
        if err != nil {
            return
        }
        err = en.WriteMapHeader(uint32(len(z.Meta)))
        if err != nil {
            err = msgp.WrapError(err, "Meta")
            return
        }
        for za0001, za0002 := range z.Meta {
            err = en.WriteString(za0001)
            if err != nil {
                err = msgp.WrapError(err, "Meta")
                return
            }
            err = en.WriteString(za0002)
            if err != nil {
                err = msgp.WrapError(err, "Meta", za0001)
                return
            }
        }
    }
    // write "span_id"
    err = en.Append(0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
    if err != nil {
        return
    }
    err = en.WriteUint64(z.SpanID)
    if err != nil {
        err = msgp.WrapError(err, "SpanID")
        return
    }
    // write "trace_id"
    err = en.Append(0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
    if err != nil {
        return
    }
    err = en.WriteUint64(z.TraceID)
    if err != nil {
        err = msgp.WrapError(err, "TraceID")
        return
    }
    // write "parent_id"
    err = en.Append(0xa9, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
    if err != nil {
        return
    }
    err = en.WriteUint64(z.ParentID)
    if err != nil {
        err = msgp.WrapError(err, "ParentID")
        return
    }
    return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Span) Msgsize() (s int) {
    s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 8 + msgp.StringPrefixSize + len(z.Service) + 6 + msgp.Int64Size + 9 + msgp.Int64Size + 5 + msgp.MapHeaderSize
    if z.Meta != nil {
        for za0001, za0002 := range z.Meta {
            _ = za0002
            s += msgp.StringPrefixSize + len(za0001) + msgp.StringPrefixSize + len(za0002)
        }
    }
    s += 8 + msgp.Uint64Size + 9 + msgp.Uint64Size + 10 + msgp.Uint64Size
    return
}

// DecodeMsg implements msgp.Decodable
func (z *SpanList) DecodeMsg(dc *msgp.Reader) (err error) {
    var zb0002 uint32
    zb0002, err = dc.ReadArrayHeader()
    if err != nil {
        err = msgp.WrapError(err)
        return
    }
    if cap((*z)) >= int(zb0002) {
        (*z) = (*z)[:zb0002]
    } else {
        (*z) = make(SpanList, zb0002)
    }
    for zb0001 := range *z {
        if dc.IsNil() {
            err = dc.ReadNil()
            if err != nil {
                err = msgp.WrapError(err, zb0001)
                return
            }
            (*z)[zb0001] = nil
        } else {
            if (*z)[zb0001] == nil {
                (*z)[zb0001] = new(Span)
            }
            err = (*z)[zb0001].DecodeMsg(dc)
            if err != nil {
                err = msgp.WrapError(err, zb0001)
                return
            }
        }
    }
    return
}

// EncodeMsg implements msgp.Encodable
func (z SpanList) EncodeMsg(en *msgp.Writer) (err error) {
    err = en.WriteArrayHeader(uint32(len(z)))
    if err != nil {
        err = msgp.WrapError(err)
        return
    }
    for zb0003 := range z {
        if z[zb0003] == nil {
            err = en.WriteNil()
            if err != nil {
                return
            }
        } else {
            err = z[zb0003].EncodeMsg(en)
            if err != nil {
                err = msgp.WrapError(err, zb0003)
                return
            }
        }
    }
    return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SpanList) Msgsize() (s int) {
    s = msgp.ArrayHeaderSize
    for zb0003 := range z {
        if z[zb0003] == nil {
            s += msgp.NilSize
        } else {
            s += z[zb0003].Msgsize()
        }
    }
    return
}
